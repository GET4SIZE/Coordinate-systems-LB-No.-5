# Coordinate-systems-LB-No.-5
Обробка координатних даних: Придушення шумів у потоці (Real-time)

## Реалізація фільтрів

### 1. SMA (Simple Moving Average)

```python
class SMAFilter:
    def __init__(self, w):
        self.w = w
        self.q = deque(maxlen=w)
        self.sum = 0.0
    
    def update(self, x):
        if len(self.q) == self.w:
            self.sum -= self.q[0]
        self.q.append(x)
        self.sum += x
        return self.sum / len(self.q)
```

**Особливості:** Оптимізація O(1) за допомогою підтримки суми. Добре давить Гауссів шум, але розмазує різкі зміни траєкторії.

### 2. EMA (Exponential Moving Average)

```python
class EMAFilter:
    def __init__(self, alpha):
        self.a = alpha
        self.last = None
    
    def update(self, x):
        if self.last is None:
            self.last = x
            return x
        self.last = self.a * x + (1 - self.a) * self.last
        return self.last
```

**Особливості:** Рекурсивний фільтр, мінімальне використання пам'яті. Швидше реагує на зміни порівняно з SMA при еквівалентних параметрах.

### 3. Median Filter

```python
class MedianFilter:
    def __init__(self, w):
        if w % 2 == 0:
            w += 1
        self.w = w
        self.q = deque(maxlen=w)
    
    def update(self, x):
        self.q.append(x)
        return np.median(self.q)
```

**Особливості:** Нелінійний фільтр. Відмінно справляється з імпульсними викидами, зберігаючи різкі зміни траєкторії.

---

## Експеримент 1: Базові параметри

**Параметри:**
- `W_SMA = 20`
- `A_EMA = 0.1`
- `W_MED = 21`

<img width="1590" height="1989" alt="image" src="https://github.com/user-attachments/assets/49dc7cc8-12cf-4285-8c3b-cd5c9b8b3ad4" />

### Аналіз результатів

#### Графік 3 (Координата Y - Змійка, 13-20 с):
<img width="1631" height="455" alt="image" src="https://github.com/user-attachments/assets/f95ef757-e85c-47a2-adc0-9db50b4d6a68" />

**Затримка фільтрів:**
- [Ваш аналіз: чи сильно відстають лінії від ідеалу?]
- [Порівняйте SMA vs EMA - який швидше реагує?]

**Поведінка на викидах:**
- Медіанний фільтр: [Ваше спостереження про те, як він впорався з різкими піками]
- SMA: [Як SMA реагує на викиди - чи розмазує їх?]

#### 2D Траєкторія (Графік 1):

- [Яка траєкторія найближча до ідеалу?]
- [Чи є "зрізання кутів" на поворотах?]

---

## Експеримент 2: Екстремальне згладжування

**Параметри:**
- `W_SMA = 100` 
- `A_EMA = 0.02` 
- `W_MED = 21` 

<img width="1590" height="1989" alt="image" src="https://github.com/user-attachments/assets/1c60dc3f-f0a9-4a4b-8f7b-5ac2216860e6" />

### Аналіз спектру помилки (Графік 4b)
<img width="812" height="478" alt="image" src="https://github.com/user-attachments/assets/bfedc62b-55db-44c5-957a-635986e57644" />

#### Зона низьких частот (0-1 Гц):

**Спостереження:**
[Опишіть, що сталося з кольоровими лініями - чи вони піднялися вище сірої лінії вхідного шуму?]

**Пояснення парадоксу:**

Це явище називається **динамічними спотвореннями** або **lag-induced error**:

1. **Механізм виникнення:**
   - При великому вікні фільтрації (W=100) фільтр "не встигає" за реальною траєкторією
   - На поворотах і синусоїдальних ділянках виникає систематична помилка - фільтр "зрізає кути"
   - Ця помилка має низькочастотний характер (повторюється з періодом маневру)

2. **Спектральний ефект:**
   - На високих частотах (>5 Гц): фільтр добре придушує шум ✅
   - На низьких частотах (<1 Гц): з'являються **нові помилки** через затримку ❌
   - Результат: загальна помилка може бути більшою, ніж вхідний шум!

3. **Практичний висновок:**
   [Ваш висновок про баланс між згладжуванням та затримкою]

---

## Експеримент 3: Малий медіанний фільтр

**Параметри:**
- `W_SMA = 20` (базовий)
- `A_EMA = 0.1` (базовий)
- `W_MED = 5` (дуже мале вікно)

<img width="1590" height="1989" alt="image" src="https://github.com/user-attachments/assets/68d95504-605d-4bb4-a969-4a5308a74972" />

### Аналіз

**Поведінка на викидах:**
- [Чи зникли всі викиди? Що відбувається з "широкими" викидами (3-5 точок підряд)?]

**Гладкість траєкторії:**
- [Порівняйте з SMA(20) - яка лінія більш "тремтлива"?]

**Висновок:**
- [Оптимальний розмір вікна для медіанного фільтра залежить від...]

---

## Загальні висновки

### 1. Видалення збоїв сенсора (імпульсні викиди):

**Найкращий фільтр:** [Median / SMA / EMA?]

**Обґрунтування:**
- [Ваше пояснення]

### 2. Плавне ведення траєкторії (мінімальна затримка):

**Найкращий фільтр:** [Median / SMA / EMA?]

**Обґрунтування:**
- [Ваше пояснення]

### 3. Універсальні рекомендації:

- Для **навігаційних систем** (GPS фільтрація): [...]
- Для **робототехніки** (відстеження об'єктів): [...]
- Для **обробки медичних сигналів** (ЕКГ з артефактами): [...]

---

## Додаткові спостереження

[Будь-які інші цікаві результати, які ви помітили під час експериментів]

---

## Використані технології

- Python 3.x
- NumPy - генерація даних та обчислення
- Matplotlib - візуалізація
- SciPy - спектральний аналіз (FFT)

## Як запустити

```bash
# У Google Colab або локально
pip install numpy matplotlib scipy
python signal_filtering_lab.py
```

Або відкрийте `.ipynb` файл у Google Colab.
